% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bridgestan.R
\name{StanModel}
\alias{StanModel}
\title{StanModel}
\description{
StanModel

StanModel
}
\details{
R6 Class representing a compiled BridgeStan model.

This model exposes log density, gradient, and Hessian information
as well as constraining and unconstraining transforms.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-StanModel-new}{\code{StanModel$new()}}
\item \href{#method-StanModel-name}{\code{StanModel$name()}}
\item \href{#method-StanModel-model_info}{\code{StanModel$model_info()}}
\item \href{#method-StanModel-param_names}{\code{StanModel$param_names()}}
\item \href{#method-StanModel-param_unc_names}{\code{StanModel$param_unc_names()}}
\item \href{#method-StanModel-param_num}{\code{StanModel$param_num()}}
\item \href{#method-StanModel-param_unc_num}{\code{StanModel$param_unc_num()}}
\item \href{#method-StanModel-param_constrain}{\code{StanModel$param_constrain()}}
\item \href{#method-StanModel-param_unconstrain}{\code{StanModel$param_unconstrain()}}
\item \href{#method-StanModel-param_unconstrain_json}{\code{StanModel$param_unconstrain_json()}}
\item \href{#method-StanModel-log_density}{\code{StanModel$log_density()}}
\item \href{#method-StanModel-log_density_gradient}{\code{StanModel$log_density_gradient()}}
\item \href{#method-StanModel-log_density_hessian}{\code{StanModel$log_density_hessian()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-new"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-new}{}}}
\subsection{Method \code{new()}}{
Create a Stan Model instace.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$new(lib, data, rng_seed, chain_id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{lib}}{A path to a compiled BridgeStan Shared Object file.}

\item{\code{data}}{A path to a JSON data file for the model.}

\item{\code{rng_seed}}{Seed for the RNG in the model object.}

\item{\code{chain_id}}{Used to offset the RNG by a fixed amount.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new StanModel.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-name"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-name}{}}}
\subsection{Method \code{name()}}{
Get the name of this StanModel
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$name()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A character vector of the name.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-model_info"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-model_info}{}}}
\subsection{Method \code{model_info()}}{
Get compile information about this Stan model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$model_info()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A character vector of the Stan version and important flags.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_names"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_names}{}}}
\subsection{Method \code{param_names()}}{
Return the indexed names of the (constrained) parameters.
For containers, indexes are separated by periods (.).

For example, the scalar \code{a} has indexed name "a", the vector entry \code{a[1]} has
indexed name "a.1" and the matrix entry \code{a[2, 3]} has indexed name "a.2.3". Parameter
order of the output is column major and more generally last-index major for containers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_names(include_tp = FALSE, include_gq = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{include_tp}}{Whether to include variables from transformed parameters.}

\item{\code{include_gq}}{Whether to include variables from generated quantities.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list of character vectors of the names.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_unc_names"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_unc_names}{}}}
\subsection{Method \code{param_unc_names()}}{
Return the indexed names of the unconstrained parameters.
For containers, indexes are separated by periods (.).

For example, the scalar \code{a} has indexed name "a", the vector entry \code{a[1]} has
indexed name "a.1" and the matrix entry \code{a[2, 3]} has indexed name "a.2.3". Parameter
order of the output is column major and more generally last-index major for containers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_unc_names()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of character vectors of the names.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_num"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_num}{}}}
\subsection{Method \code{param_num()}}{
Return the number of (constrained) parameters in the model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_num(include_tp = FALSE, include_gq = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{include_tp}}{Whether to include variables from transformed parameters.}

\item{\code{include_gq}}{Whether to include variables from generated quantities.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The number of parameters in the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_unc_num"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_unc_num}{}}}
\subsection{Method \code{param_unc_num()}}{
Return the number of unconstrained parameters in the model.

This function is mainly different from \code{param_num} when variables are declared with constraints.
For example, \code{simplex[5]} has a constrained size of 5, but an unconstrained size of 4.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_unc_num()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The number of parameters in the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_constrain"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_constrain}{}}}
\subsection{Method \code{param_constrain()}}{
This turns a vector of unconstrained params into constrained parameters
See also \code{StanModel$param_unconstrain()}, the inverse of this function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_constrain(theta_unc, include_tp = FALSE, include_gq = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta_unc}}{The vector of unconstrained parameters}

\item{\code{include_tp}}{Whether to also output the transformed parameters of the model.}

\item{\code{include_gq}}{Whether to also output the generated quantities of the model.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The constrained parameters of the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_unconstrain"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_unconstrain}{}}}
\subsection{Method \code{param_unconstrain()}}{
This turns a vector of constrained params into unconstrained parameters.

It is assumed that these will be in the same order as internally represented by
the model (e.g., in the same order as \code{StanModel$param_names()}).
If structured input is needed, use \code{StanModel$param_unconstrain_json()}.
See also \code{StanModel$param_constrain()}, the inverse of this function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_unconstrain(theta)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta}}{The vector of constrained parameters}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The unconstrained parameters of the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-param_unconstrain_json"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-param_unconstrain_json}{}}}
\subsection{Method \code{param_unconstrain_json()}}{
This accepts a JSON string of constrained parameters and returns the unconstrained parameters.

The JSON is expected to be in the \href{https://mc-stan.org/docs/cmdstan-guide/json.html}{JSON Format for CmdStan}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$param_unconstrain_json(json)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{json}}{Character vector containing a string representation of JSON data.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The unconstrained parameters of the model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-log_density"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-log_density}{}}}
\subsection{Method \code{log_density()}}{
Return the log density of the specified unconstrained parameters.
See also \code{StanModel$param_unconstrain()}, the inverse of this function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$log_density(theta, propto = TRUE, jacobian = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta}}{The vector of unconstrained parameters}

\item{\code{propto}}{If \code{TRUE}, drop terms which do not depend on the parameters.}

\item{\code{jacobian}}{If \code{TRUE}, include change of variables terms for constrained parameters.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The log density.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-log_density_gradient"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-log_density_gradient}{}}}
\subsection{Method \code{log_density_gradient()}}{
Return the log density and gradient of the specified unconstrained parameters.
See also \code{StanModel$param_unconstrain()}, the inverse of this function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$log_density_gradient(theta, propto = TRUE, jacobian = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta}}{The vector of unconstrained parameters}

\item{\code{propto}}{If \code{TRUE}, drop terms which do not depend on the parameters.}

\item{\code{jacobian}}{If \code{TRUE}, include change of variables terms for constrained parameters.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List containing entries \code{val} (the log density) and \code{gradient} (the gradient).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-StanModel-log_density_hessian"></a>}}
\if{latex}{\out{\hypertarget{method-StanModel-log_density_hessian}{}}}
\subsection{Method \code{log_density_hessian()}}{
Return the log density, gradient, and Hessian of the specified unconstrained parameters.
See also \code{StanModel$param_unconstrain()}, the inverse of this function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{StanModel$log_density_hessian(theta, propto = TRUE, jacobian = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{theta}}{The vector of unconstrained parameters}

\item{\code{propto}}{If \code{TRUE}, drop terms which do not depend on the parameters.}

\item{\code{jacobian}}{If \code{TRUE}, include change of variables terms for constrained parameters.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List containing entries \code{val} (the log density), \code{gradient} (the gradient), and \code{hessian} (the Hessian).
}
}
}
